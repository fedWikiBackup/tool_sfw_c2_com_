{
  "title": "Development Tools",
  "story": [
    {
      "type": "html",
      "text": "Please, oh please can we have some nicer development tools? So much of the time I see people bicker about this coding convention or that, and performing these transformations and refactorings on code every so often, and I think these thoughts:",
      "id": "69a69fa6af1b9fa79ce94ca4cfa757ec"
    },
    {
      "type": "html",
      "text": " We are developers. No one can develop software better than us. And yet we spend all of our time writing software for other people's work (so that we can get paid) but we don't spend any time writing software to improve our own work. Probably because no one will pay us to.",
      "id": "aeee54741197716157411a70bdb1f5ec"
    },
    {
      "type": "html",
      "text": " Lots of coding activities are creative. But a lot of other coding activities (notation, verifying method syntax, renaming things) are horribly dull and algorithmic; instead of burning our 150+ IQ brains on these tasks, we should just have tools that do this for us.",
      "id": "e6eaf6265f31fd2187de782737916270"
    },
    {
      "type": "html",
      "text": " Whenever I hear people discuss [[Development Tools]], they almost always omit discussion of the largest and most pervasive type of tools that we use:<br>[[Programming Language]]s. Languages aren't immutable, and it's not impossible to create them or extend them (it's just very difficult. :) But really, they're just tools, and if they contain \"features\" that slow us down or trip us up 90% of the time, then shouldn't we focus some energy into finding better semantics for those \"features?\" (Not that I have certain languages in mind, in particular not C++.)",
      "id": "3adb3f8a8b66e39a57cdef9a91ea486a"
    },
    {
      "type": "html",
      "text": "\nI know that [[Small Talk]] has nice tools available for it... maybe if someone has already written some tools for other languages (Java, for one) then I would be happier. So, I ask:",
      "id": "d4e2be50fc83e66086f6fd48e08b1ee8"
    },
    {
      "type": "html",
      "text": " Could you post pointers to helpful tools that you have written or know of here?",
      "id": "d513cc396d2f32ba02e5da658cbc2ed2"
    },
    {
      "type": "html",
      "text": " Does anyone know of some good strategies for getting your manager or clients to agree to let you use some company time to create tools that support your work?",
      "id": "c544ae55f7a89e45d724b55a5dd663f7"
    },
    {
      "type": "html",
      "text": " Does the concept of [[Automating Frequent Tasks]] have any place in [[Extreme Programming]]? Maybe somewhere between [[You Arent Gonna Need It]] and Refactoring?",
      "id": "c1b777856df2a18c7d39c94843f66232"
    },
    {
      "type": "html",
      "text": "-- [[Rus Heywood]]",
      "id": "91de382822759e8205f686b0c844cafb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "f3bd6ed84468529955b322ed9879ee5d"
    },
    {
      "type": "html",
      "text": "I don't recall any of the [[Extreme Programming]] pages explicitly calling out the fact that there is an attitude of [[Build Your Own Tools]] it may be buried. Both of the [[Extreme Programming Projects]] I have been part of have this <i>[[Mc Guyver]]</i> attitude of crafting the tools you need exactly when you need them. The first thing the [[Vcaps Project]] did to become extreme was when we wrote our own version of the [[Testing Framework]]. If you don't know a thing well enough to create it for yourself then you will not be able to adjust it to be exactly what you need. Also, when using someone else's tools you will be subjected to a whole lot of junk your project does not need.",
      "id": "ef1c95fdf5339f9a745e456906263f52"
    },
    {
      "type": "html",
      "text": "\nThink of it like this: Remember the last [[Star Wars]] movie, called <i>Return of the Jedi</i> I think. Luke the [[Jedi Knight]] in training is captured by the evil [[Darth Vader]]. [[Darth Vader]] has Luke's captured [[Light Sabre]] in his hands and is examining it. He says to young Luke: \"I see you have constructed your own [[Light Sabre]], your training is complete.\" -- [[Don Wells]]",
      "id": "41cdcfd21d7edf4c3f0b8d504ea7b0a0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "f3bd6ed84468529955b322ed9879ee5d"
    },
    {
      "type": "html",
      "text": "Why are we still compiling and linking programs to build applications?",
      "id": "64573998be6253e22e73ffb423472049"
    },
    {
      "type": "html",
      "text": "\nWhy is the Information Systems department of most companies almost completely unautomated?",
      "id": "b1c31cb5de9ff31d6ab7d3c7e30be1df"
    },
    {
      "type": "html",
      "text": "\nWhy not a new Paradigm? It's time for a change - [[Its Time To Dump Cee Syntax]].",
      "id": "f50e636d8bd28ba9104ca7d590458f77"
    },
    {
      "type": "html",
      "text": "\nWhy can't programs be built in such a way that the semantics of how they are connected together is treated equally to the mechanics. For example: today we use names to attempt to indicate the meaning, context and usage of a parameter of a subroutine or function. From the module's perspective, The names are quite arbitrary. Any other unique symbol can be substituted for any other. The program still works if the parameters are named in a way that is meaningless in its operational context or to its human readers. But what if at every level we were also required to specify the semantics of the interface as well as the mechanics? I'm sure I've never encountered computer languages which require this. What if there were? What would they be like?",
      "id": "40445f5426ff86184b28616c402c8172"
    },
    {
      "type": "html",
      "text": "\nWhat if the right size of a module were ",
      "id": "3e5c4ee399246c9dbd269620c9786db3"
    },
    {
      "type": "html",
      "text": " line of code or (",
      "id": "e2bf1a8354f55895c785bc3b5087ce3a"
    },
    {
      "type": "html",
      "text": " if statement",
      "id": "c93c913ba4e6b433d96585ef6bd640d6"
    },
    {
      "type": "html",
      "text": " loop construct",
      "id": "3a33eccc0f90aded33026f92fdb94208"
    },
    {
      "type": "html",
      "text": " switch statement )",
      "id": "6221ae445cd31b9d559b869d760b831e"
    },
    {
      "type": "html",
      "text": "and if statements loops and switches had to call a module with a semantically defined interface for every \"line of code\". Would this drive human programmers crazy? More to the point, how would a computer program deal with programs structured this way?",
      "id": "f558a1aa799b821492c91a34f882a022"
    },
    {
      "type": "html",
      "text": "\nWhat does the fact that this page went unedited for more than a year mean? -[[Pat Callahan]] <i>People were busy with something else?</i>",
      "id": "5fb6c75c6156c15d34935b54435943f6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "f3bd6ed84468529955b322ed9879ee5d"
    },
    {
      "type": "html",
      "text": "From [http://mozart-dev.sourceforge.net/ mozart-dev.sourceforge.net] -",
      "id": "28bacac2babdacb64fb1679e274f3047"
    },
    {
      "type": "code",
      "text": " Mozart is a logical step in the evolution of development tools. Over time, \n development tools have improved by offering increasing abstraction, as \n shown in the table below roughly in historical order, and Mozart is just\n the next step in that direction.",
      "id": "6a4886903c36b8d6b70619294aca399c"
    },
    {
      "type": "html",
      "text": "[Note:<br>this table ignores functional or declarative languages like ",
      "id": "ce519028865f47d5f572cefe92bc9bc2"
    },
    {
      "type": "code",
      "text": "  LISP or Prolog - They are different beasts entirely.]",
      "id": "a2d69b9cde74822231cea680672a3893"
    },
    {
      "type": "code",
      "text": " Technique       Languages/Tools     Comments \n --------------- ------------------- --------------------------------------------------------\n No abstraction  Binary switches     No abstraction at all offered to the programmer. \n --------------- ------------------- --------------------------------------------------------\n Assembly        Assembler           Abstract instructions encoding: ADD replaces 011001. \n Compilation     Fortran             Abstract machine dependencies: Fortran programs \n                                     execute on any machine with a Fortran compiler, \n                                     and the detailed machine instructions sequence \n                                     need no longer be known. \n --------------- ------------------- --------------------------------------------------------\n Structured\n Programming     Pascal, C           Abstract control flow structures (while, if-else, switch) \n                                     replace use of GOTO. Abstract data structures \n                                     (struct, record) replace arrays (where the programmers \n                                     had to organize data themselves). \n --------------- ------------------- --------------------------------------------------------\n Modular \n Programming      Modula, Ada         Abstract relationships between users and providers of \n                                     services are described through module interfaces. \n                                     The implementation can be hidden from the user. \n                                     Structured error handling mechanisms (exceptions) \n --------------- ------------------- -------------------------------------------------------- \n OOP              SmallTalk, C++, \n                  Objective-C, Java, \n                  Eiffel, etc.       Abstract relation between code and data. The underlying \n                                     data representation becomes irrelevant. In particular, \n                                     polymorphism allows different types of data structure \n                                     to be treated identically by the code using them. \n --------------- ------------------- -------------------------------------------------------- \n Generic\n Programming      Ada, C++           Abstract description of algorithm and data structures \n                                     that correctly specifies type relationships or \n                                     algorithmic invariants without imposing any particular \n                                     type or algorithm. \n --------------- ------------------- -------------------------------------------------------- \n Concept\n Programming      Mozart, \n                  Xroma, XL          Abstract description of \"concepts\" in application code\n                                     and of operations on application code. Effective \n                                     meta-programming. \n --------------- ------------------- --------------------------------------------------------",
      "id": "54b915d83478cb8e5ff1d942e3a797dd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "f3bd6ed84468529955b322ed9879ee5d"
    },
    {
      "type": "html",
      "text": "What about [[Programming In Wiki]]",
      "id": "6a03cd06f0cd87af8a1c4337ec0a09f4"
    },
    {
      "type": "html",
      "text": "\nSee: [[Thin Tools]], [[Aspect Oriented Programming]], [[Scid And Prism]], [[Open Cpp]], [[Blitz Plus Plus]], [[Concept Programming]], [[Gcc Introspector Project]], [[Open Java]], [[Intellij Idea]], [[Net Beans]], [[Eclipse Ide]] and [[Argo Uml]].",
      "id": "3d37f03e431de0ecc3bc1021a2fd4fe2"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DevelopmentTools c2.com]",
      "id": "70279abcef3d7118f1b7d5f273edd724"
    }
  ],
  "journal": [
    {
      "date": 1143635699000,
      "id": "ab820d2aa0158f31006cfb4e630082f9",
      "type": "create",
      "item": {
        "title": "Development Tools",
        "story": [
          {
            "type": "html",
            "text": "Please, oh please can we have some nicer development tools? So much of the time I see people bicker about this coding convention or that, and performing these transformations and refactorings on code every so often, and I think these thoughts:",
            "id": "69a69fa6af1b9fa79ce94ca4cfa757ec"
          },
          {
            "type": "html",
            "text": " We are developers. No one can develop software better than us. And yet we spend all of our time writing software for other people's work (so that we can get paid) but we don't spend any time writing software to improve our own work. Probably because no one will pay us to.",
            "id": "aeee54741197716157411a70bdb1f5ec"
          },
          {
            "type": "html",
            "text": " Lots of coding activities are creative. But a lot of other coding activities (notation, verifying method syntax, renaming things) are horribly dull and algorithmic; instead of burning our 150+ IQ brains on these tasks, we should just have tools that do this for us.",
            "id": "e6eaf6265f31fd2187de782737916270"
          },
          {
            "type": "html",
            "text": " Whenever I hear people discuss [[Development Tools]], they almost always omit discussion of the largest and most pervasive type of tools that we use:<br>[[Programming Language]]s. Languages aren't immutable, and it's not impossible to create them or extend them (it's just very difficult. :) But really, they're just tools, and if they contain \"features\" that slow us down or trip us up 90% of the time, then shouldn't we focus some energy into finding better semantics for those \"features?\" (Not that I have certain languages in mind, in particular not C++.)",
            "id": "3adb3f8a8b66e39a57cdef9a91ea486a"
          },
          {
            "type": "html",
            "text": "\nI know that [[Small Talk]] has nice tools available for it... maybe if someone has already written some tools for other languages (Java, for one) then I would be happier. So, I ask:",
            "id": "d4e2be50fc83e66086f6fd48e08b1ee8"
          },
          {
            "type": "html",
            "text": " Could you post pointers to helpful tools that you have written or know of here?",
            "id": "d513cc396d2f32ba02e5da658cbc2ed2"
          },
          {
            "type": "html",
            "text": " Does anyone know of some good strategies for getting your manager or clients to agree to let you use some company time to create tools that support your work?",
            "id": "c544ae55f7a89e45d724b55a5dd663f7"
          },
          {
            "type": "html",
            "text": " Does the concept of [[Automating Frequent Tasks]] have any place in [[Extreme Programming]]? Maybe somewhere between [[You Arent Gonna Need It]] and Refactoring?",
            "id": "c1b777856df2a18c7d39c94843f66232"
          },
          {
            "type": "html",
            "text": "-- [[Rus Heywood]]",
            "id": "91de382822759e8205f686b0c844cafb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "f3bd6ed84468529955b322ed9879ee5d"
          },
          {
            "type": "html",
            "text": "I don't recall any of the [[Extreme Programming]] pages explicitly calling out the fact that there is an attitude of [[Build Your Own Tools]] it may be buried. Both of the [[Extreme Programming Projects]] I have been part of have this <i>[[Mc Guyver]]</i> attitude of crafting the tools you need exactly when you need them. The first thing the [[Vcaps Project]] did to become extreme was when we wrote our own version of the [[Testing Framework]]. If you don't know a thing well enough to create it for yourself then you will not be able to adjust it to be exactly what you need. Also, when using someone else's tools you will be subjected to a whole lot of junk your project does not need.",
            "id": "ef1c95fdf5339f9a745e456906263f52"
          },
          {
            "type": "html",
            "text": "\nThink of it like this: Remember the last [[Star Wars]] movie, called <i>Return of the Jedi</i> I think. Luke the [[Jedi Knight]] in training is captured by the evil [[Darth Vader]]. [[Darth Vader]] has Luke's captured [[Light Sabre]] in his hands and is examining it. He says to young Luke: \"I see you have constructed your own [[Light Sabre]], your training is complete.\" -- [[Don Wells]]",
            "id": "41cdcfd21d7edf4c3f0b8d504ea7b0a0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "f3bd6ed84468529955b322ed9879ee5d"
          },
          {
            "type": "html",
            "text": "Why are we still compiling and linking programs to build applications?",
            "id": "64573998be6253e22e73ffb423472049"
          },
          {
            "type": "html",
            "text": "\nWhy is the Information Systems department of most companies almost completely unautomated?",
            "id": "b1c31cb5de9ff31d6ab7d3c7e30be1df"
          },
          {
            "type": "html",
            "text": "\nWhy not a new Paradigm? It's time for a change - [[Its Time To Dump Cee Syntax]].",
            "id": "f50e636d8bd28ba9104ca7d590458f77"
          },
          {
            "type": "html",
            "text": "\nWhy can't programs be built in such a way that the semantics of how they are connected together is treated equally to the mechanics. For example: today we use names to attempt to indicate the meaning, context and usage of a parameter of a subroutine or function. From the module's perspective, The names are quite arbitrary. Any other unique symbol can be substituted for any other. The program still works if the parameters are named in a way that is meaningless in its operational context or to its human readers. But what if at every level we were also required to specify the semantics of the interface as well as the mechanics? I'm sure I've never encountered computer languages which require this. What if there were? What would they be like?",
            "id": "40445f5426ff86184b28616c402c8172"
          },
          {
            "type": "html",
            "text": "\nWhat if the right size of a module were ",
            "id": "3e5c4ee399246c9dbd269620c9786db3"
          },
          {
            "type": "html",
            "text": " line of code or (",
            "id": "e2bf1a8354f55895c785bc3b5087ce3a"
          },
          {
            "type": "html",
            "text": " if statement",
            "id": "c93c913ba4e6b433d96585ef6bd640d6"
          },
          {
            "type": "html",
            "text": " loop construct",
            "id": "3a33eccc0f90aded33026f92fdb94208"
          },
          {
            "type": "html",
            "text": " switch statement )",
            "id": "6221ae445cd31b9d559b869d760b831e"
          },
          {
            "type": "html",
            "text": "and if statements loops and switches had to call a module with a semantically defined interface for every \"line of code\". Would this drive human programmers crazy? More to the point, how would a computer program deal with programs structured this way?",
            "id": "f558a1aa799b821492c91a34f882a022"
          },
          {
            "type": "html",
            "text": "\nWhat does the fact that this page went unedited for more than a year mean? -[[Pat Callahan]] <i>People were busy with something else?</i>",
            "id": "5fb6c75c6156c15d34935b54435943f6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "f3bd6ed84468529955b322ed9879ee5d"
          },
          {
            "type": "html",
            "text": "From [http://mozart-dev.sourceforge.net/ mozart-dev.sourceforge.net] -",
            "id": "28bacac2babdacb64fb1679e274f3047"
          },
          {
            "type": "code",
            "text": " Mozart is a logical step in the evolution of development tools. Over time, \n development tools have improved by offering increasing abstraction, as \n shown in the table below roughly in historical order, and Mozart is just\n the next step in that direction.",
            "id": "6a4886903c36b8d6b70619294aca399c"
          },
          {
            "type": "html",
            "text": "[Note:<br>this table ignores functional or declarative languages like ",
            "id": "ce519028865f47d5f572cefe92bc9bc2"
          },
          {
            "type": "code",
            "text": "  LISP or Prolog - They are different beasts entirely.]",
            "id": "a2d69b9cde74822231cea680672a3893"
          },
          {
            "type": "code",
            "text": " Technique       Languages/Tools     Comments \n --------------- ------------------- --------------------------------------------------------\n No abstraction  Binary switches     No abstraction at all offered to the programmer. \n --------------- ------------------- --------------------------------------------------------\n Assembly        Assembler           Abstract instructions encoding: ADD replaces 011001. \n Compilation     Fortran             Abstract machine dependencies: Fortran programs \n                                     execute on any machine with a Fortran compiler, \n                                     and the detailed machine instructions sequence \n                                     need no longer be known. \n --------------- ------------------- --------------------------------------------------------\n Structured\n Programming     Pascal, C           Abstract control flow structures (while, if-else, switch) \n                                     replace use of GOTO. Abstract data structures \n                                     (struct, record) replace arrays (where the programmers \n                                     had to organize data themselves). \n --------------- ------------------- --------------------------------------------------------\n Modular \n Programming      Modula, Ada         Abstract relationships between users and providers of \n                                     services are described through module interfaces. \n                                     The implementation can be hidden from the user. \n                                     Structured error handling mechanisms (exceptions) \n --------------- ------------------- -------------------------------------------------------- \n OOP              SmallTalk, C++, \n                  Objective-C, Java, \n                  Eiffel, etc.       Abstract relation between code and data. The underlying \n                                     data representation becomes irrelevant. In particular, \n                                     polymorphism allows different types of data structure \n                                     to be treated identically by the code using them. \n --------------- ------------------- -------------------------------------------------------- \n Generic\n Programming      Ada, C++           Abstract description of algorithm and data structures \n                                     that correctly specifies type relationships or \n                                     algorithmic invariants without imposing any particular \n                                     type or algorithm. \n --------------- ------------------- -------------------------------------------------------- \n Concept\n Programming      Mozart, \n                  Xroma, XL          Abstract description of \"concepts\" in application code\n                                     and of operations on application code. Effective \n                                     meta-programming. \n --------------- ------------------- --------------------------------------------------------",
            "id": "54b915d83478cb8e5ff1d942e3a797dd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "f3bd6ed84468529955b322ed9879ee5d"
          },
          {
            "type": "html",
            "text": "What about [[Programming In Wiki]]",
            "id": "6a03cd06f0cd87af8a1c4337ec0a09f4"
          },
          {
            "type": "html",
            "text": "\nSee: [[Thin Tools]], [[Aspect Oriented Programming]], [[Scid And Prism]], [[Open Cpp]], [[Blitz Plus Plus]], [[Concept Programming]], [[Gcc Introspector Project]], [[Open Java]], [[Intellij Idea]], [[Net Beans]], [[Eclipse Ide]] and [[Argo Uml]].",
            "id": "3d37f03e431de0ecc3bc1021a2fd4fe2"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DevelopmentTools c2.com]",
            "id": "70279abcef3d7118f1b7d5f273edd724"
          }
        ]
      }
    }
  ]
}