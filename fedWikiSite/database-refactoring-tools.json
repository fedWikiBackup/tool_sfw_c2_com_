{
  "title": "Database Refactoring Tools",
  "story": [
    {
      "type": "html",
      "text": "Is it surprising that we have tools like [[Re Shaper]] or Ideal IntelliJ, or Eclipse that make it really easy to refactor our code to make it fit better the domain of our requirements, but there are almost no tools to do that for Databases?\nA good [[Database Refactoring Tool]] should make it easy to:",
      "id": "068bbca987ea0c89d42b5ed7d2226bb9"
    },
    {
      "type": "html",
      "text": "Change the multiplicity relation between tables (from [[One To One]] to [[One To Many]] or to [[Many To Many]] in a single click)",
      "id": "f4e006ccb8b0c974087d13801881a7fb"
    },
    {
      "type": "html",
      "text": "Increase or decrease the normalization of a design without losing data, and without having to write a very complicated SQL Script",
      "id": "2ebac335e9ca88c0d8a135cff00544ad"
    },
    {
      "type": "html",
      "text": "Split a table into two tables, and automatically rewrite the referencing stored procedures, views, and so on.",
      "id": "b9ceeebf79f9f2cfc8f286f483b572fe"
    },
    {
      "type": "html",
      "text": "Join two tables in to one, and automatically rewrite the referencing stored procedures, views, and so on.",
      "id": "f1c7d990dcc7619265e56902bfaf36cc"
    },
    {
      "type": "html",
      "text": "Allow to remember the re-factorizations applied to the development database, and re-apply them, to the production database.",
      "id": "7f7684c5d560818abcba93c419154259"
    },
    {
      "type": "html",
      "text": "Work for lots of different databases (<b>not only for [[Sql Server]] or only for Oracle</b>)",
      "id": "7a4dfe8f132cb5abcf770dca92a4f7d3"
    },
    {
      "type": "html",
      "text": "Rename functions, views, stored procedures and tables, and updates all the references to these renamed objects.",
      "id": "58217864c864d299443ca2adc11b275a"
    },
    {
      "type": "html",
      "text": "Rename parameters and columns renames parameters of stored procedures and functions, and columns of tables and views.",
      "id": "8af843368f9b20eab70b82cb29935400"
    },
    {
      "type": "html",
      "text": "Schema comparison and automatic (or semi automatic) script creation to convert from one schema design to the other",
      "id": "7c8b6392bda0bf209711240e53b315a6"
    },
    {
      "type": "html",
      "text": "Easily add or remove a column from a Table",
      "id": "6835ff0e80e26b36cb8045128f8a6135"
    },
    {
      "type": "html",
      "text": "Easily change the type of a column (if the change doesn't damage data, it should be super easy to change from Integer to Long, or from Integer to Float, or form Integer to String, and if can damage data like for example from Float to Integer or from String to Integer it should automatically verify if the conversion is possible given the current values of the column, and if is not possible, generate a query that shows you which rows have the offending values)",
      "id": "45bccb443b7f7a82c483577891076cf0"
    },
    {
      "type": "html",
      "text": "Encapsulate As New Stored Procedure turns your selection into a new stored procedure and, if requested, introduces a reference to it in your script.",
      "id": "949c1238ef38c9920e4832d71314fe57"
    },
    {
      "type": "html",
      "text": "Expand Wildcards expands SELECT * statements to include a full list of columns in the select part.",
      "id": "d751f45a62dadd82e5af790cee1f73b7"
    },
    {
      "type": "html",
      "text": "And the <b>[[Ultimate Problem]]</b>, propagating the effect of your refactorings to client code",
      "id": "207386f8df4f9b72cdf8080aef1b8c2d"
    },
    {
      "type": "html",
      "text": "Easily drop tables (even if connected with other by serveral integrity constraints, it should also make it possible to delete those foreign keys if desired)",
      "id": "141453afd339681136c7f7d91d3fba3b"
    },
    {
      "type": "html",
      "text": "Easily change the type of primary keys or foreign keys (from String to Integer or something else) and propagate the changes to referenced primary keys or foreign keys",
      "id": "c513a0f45f955012cd2f01c59899ddcb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "da3f3b626c4065e92c69209b6b0591f3"
    },
    {
      "type": "html",
      "text": "\nExamples of these kind of tools:",
      "id": "e756be79343cc49d05cde9524cee1cf8"
    },
    {
      "type": "html",
      "text": "[[Visual Studio Team Edition For Database Professionals]]",
      "id": "0317dc32a140cb92282d9b0f6ed87243"
    },
    {
      "type": "html",
      "text": "[[Red Gate Sql Refactor]]",
      "id": "e8ede4997a5b4da9624f3e4ed550c2e1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "da3f3b626c4065e92c69209b6b0591f3"
    },
    {
      "type": "html",
      "text": "\nA strange thing in the world of database design and admistration is that we have lots of tools to may lots of silly diagrams, but we do not have many tools to do [[Database Refactoring]]... why is that? (Maybe it is because bad Dbas do not want anyone to know that they could be replaced by a tool?)",
      "id": "49ce79faa3c24e77b664eeb18265a613"
    },
    {
      "type": "html",
      "text": "<i>As someone who has made several false starts at creating such a tool, I think the biggest obstacles are:</i>",
      "id": "67e287859cf55cf5d0f22d649f5659a3"
    },
    {
      "type": "html",
      "text": " <i>As programming goes, this turns out to be particularly tedious, un-challenging, un-interesting, and un-sexy;</i>",
      "id": "ee17f28b45f29d3ecd840857e26cf773"
    },
    {
      "type": "html",
      "text": " un-challenging? you mean it is easy?",
      "id": "3823d981be0b5a589e57bda4e54d7e1d"
    },
    {
      "type": "html",
      "text": " <i>Essentially, yes.  Except for \"schema comparison and automatic (or semi automatic) script creation to convert from one schema design to the other\", almost all of the above are straightforward, except a few that strike me as nearly impossible to automate.</i>",
      "id": "89c86c7e83b32bef14fad16bd056a97f"
    },
    {
      "type": "html",
      "text": " So, database refactoring it is so easy that is impossible?... Mmmm... paradoxical concept",
      "id": "c53e0f94555c007e350072f43ae7b428"
    },
    {
      "type": "html",
      "text": " <i>Not really.  Most of the operations are trivial.  Some operations are relatively easy for a human to do, but very difficult if not impossible to automate, like auto-generating the SQL to morph one schema into another -- except in trivial cases.  Keep in mind that this could involve re-writing stored procedures in non-trivial ways.  Indeed, any operation that require significant alterations to stored procedures are unlikely to be automatable, except in trivial cases, but a human programmer can do this easily.</i>",
      "id": "34e7f96d59c5106ea04cb70cc31e00bd"
    },
    {
      "type": "html",
      "text": " tedious, un-interesting, and un-sexy? really you think those are the real motivators for lack of availability of this kind of tool?  ",
      "id": "d71c84172a6a3cabbd533f589409b6ae"
    },
    {
      "type": "html",
      "text": " <i>They're certainly responsible for <b>my</b> lack of motivation, but the fact that database refactoring occupies such a small percentage of development/maintenance time is probably a more significant factor.  See below.</i>",
      "id": "833e2db633106ab0e6c529b996aa79a2"
    },
    {
      "type": "html",
      "text": " <i>If you're a database professional, there's always plenty of work around that's more profitable in the short term;</i>",
      "id": "79cd42d880abeb6fcf5f92d930a4a400"
    },
    {
      "type": "html",
      "text": " In other words, you believe that in the world of databases the objective should be to [[Just Make It Work]] (You just don't care if it becomes a maintenance nightmare?)",
      "id": "f46ece432af09ea5a1bc2fdb472f3d7e"
    },
    {
      "type": "html",
      "text": " <i>Such tools may expedite refactoring, but they don't do anything that can't be done manually.</i> ",
      "id": "053a421d6186670b5730617fa4edf905"
    },
    {
      "type": "html",
      "text": " Yeah, there is nothing as exiting, challenging, interesting and sexy than having to manually fix all those functions, views, and stored procedures  just because you need to rename some tables and fields, and after that there is nothing like the excitement of wondering:did I break anything? pure bliss... in fact, who cares if the name of the table/fields have nothing to do with the [[Ubiquitous Language]] of the domain experts... only kids are afraid of maintenance nightmares",
      "id": "44ab61aee905cc08c4c36024da5de0c8"
    },
    {
      "type": "html",
      "text": " <i>I think you're ranting rather than making a point, but...  Trivial renamings are just that -- trivial.  They're easily testable on the development database, too.  Non-trivial refactorings -- i.e., those that require changes to the functionality of stored procedures -- are not automatable anyway, so there's little gain to be had.  There may, however, be </i>some<i> gain to be had, so feel free to write a database refactoring tool.  I'll happily test it for you.</i>",
      "id": "2b49e3d12ab400ab4fb41bc8423ab0a6"
    },
    {
      "type": "html",
      "text": " It is not that I think that trivial renamings are not trivial, it is just that I do not like [[Grunt Work]], do you? It is also that I have seen too many databases with wrong names everywhere and developers or Dba that say that they \"just don't have time\" to fix them (they may be trivial, but they can not be done in trivial time)",
      "id": "6f489ca757230e251037ebe3a38c356d"
    },
    {
      "type": "html",
      "text": " <i>Fair enough.  Like I said before, feel free to write a database refactoring tool; I'll be happy to test it for you.  However, keep in mind that part (if not most) of the reluctance to changing the database may not lie with the database itself.  There may be dozens of client-side applications dependent on that database.  They'll have to be changed and re-deployed too.</i>",
      "id": "59fe55f3262cffed24677a1bf9b00391"
    },
    {
      "type": "html",
      "text": " Well, that might be a case for LINQ, with something like that, your client code would be strongly tied to the database structure and it would be trivial to automatically propagate trivial renaming from the database to the client applications... and therefore [[Object Relational Mappers]] are a [[Good Thing]], because they make it possible to automate this kind of changes... (Believe me, a tool that could do this would save anyone lots of [[Grunt Work]], don't you think?). Or, if you do not like the Object part in [[Object Relational Mapper]]... maybe the answer is to create a [[Client Application To Database Mapper]] that makes it possible to automate this kind of changes (and it should replace silly [[Grunt Work]] prone database Apis like JDBC or ADO.NET)",
      "id": "4d16e985469b5f1b734f5f4127533eda"
    },
    {
      "type": "html",
      "text": " <i>Since they're done relatively infrequently (see below), they're the kind of thing that when you have to do an individual task, you sometimes think \"Gee, I wish there was a tool to do this.\"  Then you finish the task (i.e., preserve the SQL that implements the refactoring) and spend the majority of your time on other things and simply forget about it.  I've never found this sort of thing a maintenance nightmare.  Annoying at times, yes.  A nightmare, no.  Since most such refactorings have to be deployed to production databases in the field, they're invariably expressed as SQL scripts rather than interactive changes.  It's a matter, therefore, of writing some code.</i>",
      "id": "08df7ed5cca423e7f67af7ebd9840c7a"
    },
    {
      "type": "html",
      "text": " <i>Database refactoring, manual or otherwise, occupies such a small percentage of the overall database-driven application development process that most of the time it seems not worth bothering.</i>",
      "id": "943c108654d6c8b573b419cce1f9f07c"
    },
    {
      "type": "html",
      "text": " Really? or that is just some more of that I [[Just Dont Care If It Becomesa Maintenance Mightmare]] philosophy? ",
      "id": "4cfdc04066833777728765f348229e24"
    },
    {
      "type": "html",
      "text": " <i>Really.  >99% of my time is spent working on the application(s) side; <1% is spent working on the database, and that includes some big schemas that change relatively frequently.  For every minute spent making a change to the database, there will probably be at least an hour spent accommodating the change on the application side, unless it's a trivial change.  Having said that, I think such a tool is a great idea.  I'm not deprecating that.  I'm simply pointing out why I think it isn't a significant application category.</i>",
      "id": "811606555df9b643eb26810749baa3de"
    },
    {
      "type": "html",
      "text": " Well, that maybe so, specially if you are like me and use an [[Object Relational Mapper]] (and unlike those that believe that [[Databases Are More Than Just Storage]] and do code in stored procedures ,views and user functions)",
      "id": "31bf586ab4bc307e2c4a031820a984bd"
    },
    {
      "type": "html",
      "text": " <i>I don't use an [[Object Relational Mapper]], and I believe that [[Databases Are More Than Just Storage]] and a [[Database Is Representer Of Facts]].</i>",
      "id": "168b2896dc71f65aa363686b7e97d7e6"
    },
    {
      "type": "html",
      "text": " Well, then it is really amazing that >99% of your time is spent working on the application(s) side, if you do belive [[Databases Are More Than Just Storage]], then, how can you spend such a little time in the database? you certainly can not have a lot of your code in stored procedures, functions, triggers and stuff like that. ",
      "id": "e4ae0e1384b43096a1ed1da963f342a0"
    },
    {
      "type": "html",
      "text": " If you believe that [[Database Refactoring Tools]] will not help you... I [[Just Dont Get It]]... How can you believe that [[Databases Are More Than Just Storage]] and at the same time use them only for storage? (If you never write functions, triggers and stuff like that, and 99% of you code is on the application... and you don't like [[Object Relational Mappers]]... I am starting to believe that you may be masochistic... Maybe I just don't get how you code... ",
      "id": "be8099ebe88e116aa6d4e80911abe405"
    },
    {
      "type": "html",
      "text": " <i>The volume of application-side code is proportionally vast compared to the database-side code, and there is typically one database shared by multiple applications.  Stored procedures and triggers are typically used to handle specific core server-side functionality -- such as to support an employee scheduling engine, for example -- and change relatively rarely compared to the application-side.  The need for column, table, or procedure renamings is rare.  Deletions of columns or procedures is rare.  Much, much more common is adding tables and columns, which result in a relatively small server-side change volume, but may effect multiple client-side applications, and may require changes throughout each client-side application.  Also, changes to client-side applications or development of new applications that require no database changes are relatively common.  However, I do recognise that this may be somewhat domain-specific.  I can imagine domains where the database might require massive changes to reflect significant business changes, but that would still require significant -- and proportionally large -- changes to client-side applications.  In that case, I would be inclined to deploy a new schema and database that imports the existing one, rather than refactor the existing database.  Finally, I take an approach that does not mirror whole database entities as client-side objects.  I build applications to process information, i.e., facts; I do not create business simulators.  And, I'm not saying [[Database Refactoring Tools]] wouldn't help at all, just that they wouldn't help enough to motivate me to finish building one.</i>",
      "id": "7843348d540c0b6b2b452f23ce06eb8f"
    },
    {
      "type": "html",
      "text": " I can think of a very common time when the database might require massive changes to reflect significant business changes, and that is when you are creating the system for the first time, and, as  always, the requirements change every day.",
      "id": "d13f115177b2d6d24782567826e4ebab"
    },
    {
      "type": "html",
      "text": " <i>Yes, I've seen poorly-managed and/or poorly-analysed projects go haywire in that manner in the early stages, and a refactoring tool might help relieve the pain thereof.  Still, the percentage of overall project time that will be spent on the database, as opposed to working on the application-side code, is likely to be very small once the database requirements have stabilised.</i>",
      "id": "530e0367eb59f7ea8e04519ea951e3f3"
    },
    {
      "type": "html",
      "text": " Mmmm, what you say gives me the impression that you tend to get your database designs right on the first try (Something that in my opinion rarely happens, specially because Customers are not so good at explaining what do they expect from the software). Your customers usually have all their requirements correctly specified right from the beginning? Or... Do you handle this change in a way that wouldn't  be helped by [[Database Refactoring Tools]]? if that is the case... can you explain your methodology?.",
      "id": "9daf62e445bd529a592ff70896bbcbb6"
    },
    {
      "type": "html",
      "text": " <i>On the first try, I get the database design 100% right 0% of the time, 99% right about 1% of the time, but (throwing arbitrary statistics around here), I get it 95% right almost 100% of the time.  Most of the changes, however, tend to be minor -- adding columns, occasionally changing column type, and sometimes adding tables or turning an existing table into two in order to capture a one-to-many that escaped initial analysis.  Wholesale changes that necessitate a new schema?  Very rare.  Some reasons for this:</i>",
      "id": "b452aff3283c16ff61793735e9d9cb62"
    },
    {
      "type": "html",
      "text": " <i>We primarily (but not exclusively) developed (I'm using the past tense because I'm mainly doing university lecturing now) financial accounting, employee scheduling, billing, payroll and inventory systems, which generally have clear database design requirements even before analysis.  There are only so many ways to build a Canadian payroll system, for example, and the majority of core requirements are specified in government-provided documents.</i>",
      "id": "327a8d7697a7404f07bbc85b9071e5cd"
    },
    {
      "type": "html",
      "text": " <i>We employed a requirements-gathering methodology we developed in-house called the Forms-Based Analysis Method, which uses a combination of a diagramming methodology and a set of structured questions that are highly successful in reliably eliciting database requirements from the users.  (Published, with a co-author, in the Proceedings of the Western Decision Sciences Conference, San Francisco, California. 1995)</i>",
      "id": "e6201b0d8f7f782e28313e20a806173d"
    },
    {
      "type": "html",
      "text": " <i>The above is essentially [[Big Design Up Front]], rather than an agile methodology.  Subsequent client-side development is agile.  This combination seems quite effective in minimising difficult changes.</i>",
      "id": "a9a6706b20d0b73842592d1c5c38e9d6"
    },
    {
      "type": "html",
      "text": " <i>During development -- when little or no data need be retained -- the database schema can be trivially dumped, edited as a text file, and re-loaded.</i>",
      "id": "31cd5b988a487ada3d914bf3d20c00ba"
    },
    {
      "type": "html",
      "text": " <i>Sometimes changes are needed after deployment, but these are very rarely significant, as the users have generally been closely involved throughout the process.  We used an inversion of [[Onsite Customer]], in which the consultant developer spends significant time on the client's site -- sometimes even acting in an employee role -- in order to elicit and determine requirements, and obtain feedback on initial releases.</i>",
      "id": "8bca58f0966cbaf3160a641b61ce7575"
    },
    {
      "type": "html",
      "text": " <i>While application requirements are often unclear and changeable, database requirements tend to be quite rigid.  A given enterprise, department, or organisation tends to have numerous ways to clearly indicate exactly what it needs to record about its Customers, Employees, Products, etc.  These are found on printed forms, existing computer systems, Post-It(tm) Notes, catalogues, or whatever the business currently uses to record and/or distribute relevant information.  This becomes the basis of the database design.  What tends to change or be poorly-understood (or poorly-communicated by the users) is what the business </i>does<i> with this information.  That becomes the basis of client-side application functionality.</i>",
      "id": "2fd7ff2249528bbd7ac5a72031c9694f"
    },
    {
      "type": "html",
      "text": " And the idea of creating an [[Client Application To Database Mapper]] to make it possible to do refactorings all the way from the database to the client application would tempt you?",
      "id": "24ae3cf25328348869dd2b32beda68d3"
    },
    {
      "type": "html",
      "text": " <i>Yes, essentially.  I've added a comment to that effect to [[Client Application To Database Mapper]], though my idea is broader in scope than just a mapping layer.</i>",
      "id": "4ff65806df4a123aad37c5f19bf96972"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "da3f3b626c4065e92c69209b6b0591f3"
    },
    {
      "type": "html",
      "text": "\nSee also [[Table Normalization Issues]], [[Improve Databases Or Else]], [[Refactoring Databases Book]]",
      "id": "847d890d934b2eca1795b36031747909"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "da3f3b626c4065e92c69209b6b0591f3"
    },
    {
      "type": "html",
      "text": "[[April Zero Eight]]",
      "id": "e8460132d80b4497256a922a6911fd52"
    },
    {
      "type": "html",
      "text": "\n[[Category Refactoring]] [[Category Database]]",
      "id": "363d5e5b5e0a4f19045f2b3ca7686228"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DatabaseRefactoringTools c2.com]",
      "id": "75fa20b7f1974034e169a80d2e13bbb9"
    }
  ],
  "journal": [
    {
      "date": 1208203627000,
      "id": "a15ccc6baa4b532b7400de3fcc05e904",
      "type": "create",
      "item": {
        "title": "Database Refactoring Tools",
        "story": [
          {
            "type": "html",
            "text": "Is it surprising that we have tools like [[Re Shaper]] or Ideal IntelliJ, or Eclipse that make it really easy to refactor our code to make it fit better the domain of our requirements, but there are almost no tools to do that for Databases?\nA good [[Database Refactoring Tool]] should make it easy to:",
            "id": "068bbca987ea0c89d42b5ed7d2226bb9"
          },
          {
            "type": "html",
            "text": "Change the multiplicity relation between tables (from [[One To One]] to [[One To Many]] or to [[Many To Many]] in a single click)",
            "id": "f4e006ccb8b0c974087d13801881a7fb"
          },
          {
            "type": "html",
            "text": "Increase or decrease the normalization of a design without losing data, and without having to write a very complicated SQL Script",
            "id": "2ebac335e9ca88c0d8a135cff00544ad"
          },
          {
            "type": "html",
            "text": "Split a table into two tables, and automatically rewrite the referencing stored procedures, views, and so on.",
            "id": "b9ceeebf79f9f2cfc8f286f483b572fe"
          },
          {
            "type": "html",
            "text": "Join two tables in to one, and automatically rewrite the referencing stored procedures, views, and so on.",
            "id": "f1c7d990dcc7619265e56902bfaf36cc"
          },
          {
            "type": "html",
            "text": "Allow to remember the re-factorizations applied to the development database, and re-apply them, to the production database.",
            "id": "7f7684c5d560818abcba93c419154259"
          },
          {
            "type": "html",
            "text": "Work for lots of different databases (<b>not only for [[Sql Server]] or only for Oracle</b>)",
            "id": "7a4dfe8f132cb5abcf770dca92a4f7d3"
          },
          {
            "type": "html",
            "text": "Rename functions, views, stored procedures and tables, and updates all the references to these renamed objects.",
            "id": "58217864c864d299443ca2adc11b275a"
          },
          {
            "type": "html",
            "text": "Rename parameters and columns renames parameters of stored procedures and functions, and columns of tables and views.",
            "id": "8af843368f9b20eab70b82cb29935400"
          },
          {
            "type": "html",
            "text": "Schema comparison and automatic (or semi automatic) script creation to convert from one schema design to the other",
            "id": "7c8b6392bda0bf209711240e53b315a6"
          },
          {
            "type": "html",
            "text": "Easily add or remove a column from a Table",
            "id": "6835ff0e80e26b36cb8045128f8a6135"
          },
          {
            "type": "html",
            "text": "Easily change the type of a column (if the change doesn't damage data, it should be super easy to change from Integer to Long, or from Integer to Float, or form Integer to String, and if can damage data like for example from Float to Integer or from String to Integer it should automatically verify if the conversion is possible given the current values of the column, and if is not possible, generate a query that shows you which rows have the offending values)",
            "id": "45bccb443b7f7a82c483577891076cf0"
          },
          {
            "type": "html",
            "text": "Encapsulate As New Stored Procedure turns your selection into a new stored procedure and, if requested, introduces a reference to it in your script.",
            "id": "949c1238ef38c9920e4832d71314fe57"
          },
          {
            "type": "html",
            "text": "Expand Wildcards expands SELECT * statements to include a full list of columns in the select part.",
            "id": "d751f45a62dadd82e5af790cee1f73b7"
          },
          {
            "type": "html",
            "text": "And the <b>[[Ultimate Problem]]</b>, propagating the effect of your refactorings to client code",
            "id": "207386f8df4f9b72cdf8080aef1b8c2d"
          },
          {
            "type": "html",
            "text": "Easily drop tables (even if connected with other by serveral integrity constraints, it should also make it possible to delete those foreign keys if desired)",
            "id": "141453afd339681136c7f7d91d3fba3b"
          },
          {
            "type": "html",
            "text": "Easily change the type of primary keys or foreign keys (from String to Integer or something else) and propagate the changes to referenced primary keys or foreign keys",
            "id": "c513a0f45f955012cd2f01c59899ddcb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "da3f3b626c4065e92c69209b6b0591f3"
          },
          {
            "type": "html",
            "text": "\nExamples of these kind of tools:",
            "id": "e756be79343cc49d05cde9524cee1cf8"
          },
          {
            "type": "html",
            "text": "[[Visual Studio Team Edition For Database Professionals]]",
            "id": "0317dc32a140cb92282d9b0f6ed87243"
          },
          {
            "type": "html",
            "text": "[[Red Gate Sql Refactor]]",
            "id": "e8ede4997a5b4da9624f3e4ed550c2e1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "da3f3b626c4065e92c69209b6b0591f3"
          },
          {
            "type": "html",
            "text": "\nA strange thing in the world of database design and admistration is that we have lots of tools to may lots of silly diagrams, but we do not have many tools to do [[Database Refactoring]]... why is that? (Maybe it is because bad Dbas do not want anyone to know that they could be replaced by a tool?)",
            "id": "49ce79faa3c24e77b664eeb18265a613"
          },
          {
            "type": "html",
            "text": "<i>As someone who has made several false starts at creating such a tool, I think the biggest obstacles are:</i>",
            "id": "67e287859cf55cf5d0f22d649f5659a3"
          },
          {
            "type": "html",
            "text": " <i>As programming goes, this turns out to be particularly tedious, un-challenging, un-interesting, and un-sexy;</i>",
            "id": "ee17f28b45f29d3ecd840857e26cf773"
          },
          {
            "type": "html",
            "text": " un-challenging? you mean it is easy?",
            "id": "3823d981be0b5a589e57bda4e54d7e1d"
          },
          {
            "type": "html",
            "text": " <i>Essentially, yes.  Except for \"schema comparison and automatic (or semi automatic) script creation to convert from one schema design to the other\", almost all of the above are straightforward, except a few that strike me as nearly impossible to automate.</i>",
            "id": "89c86c7e83b32bef14fad16bd056a97f"
          },
          {
            "type": "html",
            "text": " So, database refactoring it is so easy that is impossible?... Mmmm... paradoxical concept",
            "id": "c53e0f94555c007e350072f43ae7b428"
          },
          {
            "type": "html",
            "text": " <i>Not really.  Most of the operations are trivial.  Some operations are relatively easy for a human to do, but very difficult if not impossible to automate, like auto-generating the SQL to morph one schema into another -- except in trivial cases.  Keep in mind that this could involve re-writing stored procedures in non-trivial ways.  Indeed, any operation that require significant alterations to stored procedures are unlikely to be automatable, except in trivial cases, but a human programmer can do this easily.</i>",
            "id": "34e7f96d59c5106ea04cb70cc31e00bd"
          },
          {
            "type": "html",
            "text": " tedious, un-interesting, and un-sexy? really you think those are the real motivators for lack of availability of this kind of tool?  ",
            "id": "d71c84172a6a3cabbd533f589409b6ae"
          },
          {
            "type": "html",
            "text": " <i>They're certainly responsible for <b>my</b> lack of motivation, but the fact that database refactoring occupies such a small percentage of development/maintenance time is probably a more significant factor.  See below.</i>",
            "id": "833e2db633106ab0e6c529b996aa79a2"
          },
          {
            "type": "html",
            "text": " <i>If you're a database professional, there's always plenty of work around that's more profitable in the short term;</i>",
            "id": "79cd42d880abeb6fcf5f92d930a4a400"
          },
          {
            "type": "html",
            "text": " In other words, you believe that in the world of databases the objective should be to [[Just Make It Work]] (You just don't care if it becomes a maintenance nightmare?)",
            "id": "f46ece432af09ea5a1bc2fdb472f3d7e"
          },
          {
            "type": "html",
            "text": " <i>Such tools may expedite refactoring, but they don't do anything that can't be done manually.</i> ",
            "id": "053a421d6186670b5730617fa4edf905"
          },
          {
            "type": "html",
            "text": " Yeah, there is nothing as exiting, challenging, interesting and sexy than having to manually fix all those functions, views, and stored procedures  just because you need to rename some tables and fields, and after that there is nothing like the excitement of wondering:did I break anything? pure bliss... in fact, who cares if the name of the table/fields have nothing to do with the [[Ubiquitous Language]] of the domain experts... only kids are afraid of maintenance nightmares",
            "id": "44ab61aee905cc08c4c36024da5de0c8"
          },
          {
            "type": "html",
            "text": " <i>I think you're ranting rather than making a point, but...  Trivial renamings are just that -- trivial.  They're easily testable on the development database, too.  Non-trivial refactorings -- i.e., those that require changes to the functionality of stored procedures -- are not automatable anyway, so there's little gain to be had.  There may, however, be </i>some<i> gain to be had, so feel free to write a database refactoring tool.  I'll happily test it for you.</i>",
            "id": "2b49e3d12ab400ab4fb41bc8423ab0a6"
          },
          {
            "type": "html",
            "text": " It is not that I think that trivial renamings are not trivial, it is just that I do not like [[Grunt Work]], do you? It is also that I have seen too many databases with wrong names everywhere and developers or Dba that say that they \"just don't have time\" to fix them (they may be trivial, but they can not be done in trivial time)",
            "id": "6f489ca757230e251037ebe3a38c356d"
          },
          {
            "type": "html",
            "text": " <i>Fair enough.  Like I said before, feel free to write a database refactoring tool; I'll be happy to test it for you.  However, keep in mind that part (if not most) of the reluctance to changing the database may not lie with the database itself.  There may be dozens of client-side applications dependent on that database.  They'll have to be changed and re-deployed too.</i>",
            "id": "59fe55f3262cffed24677a1bf9b00391"
          },
          {
            "type": "html",
            "text": " Well, that might be a case for LINQ, with something like that, your client code would be strongly tied to the database structure and it would be trivial to automatically propagate trivial renaming from the database to the client applications... and therefore [[Object Relational Mappers]] are a [[Good Thing]], because they make it possible to automate this kind of changes... (Believe me, a tool that could do this would save anyone lots of [[Grunt Work]], don't you think?). Or, if you do not like the Object part in [[Object Relational Mapper]]... maybe the answer is to create a [[Client Application To Database Mapper]] that makes it possible to automate this kind of changes (and it should replace silly [[Grunt Work]] prone database Apis like JDBC or ADO.NET)",
            "id": "4d16e985469b5f1b734f5f4127533eda"
          },
          {
            "type": "html",
            "text": " <i>Since they're done relatively infrequently (see below), they're the kind of thing that when you have to do an individual task, you sometimes think \"Gee, I wish there was a tool to do this.\"  Then you finish the task (i.e., preserve the SQL that implements the refactoring) and spend the majority of your time on other things and simply forget about it.  I've never found this sort of thing a maintenance nightmare.  Annoying at times, yes.  A nightmare, no.  Since most such refactorings have to be deployed to production databases in the field, they're invariably expressed as SQL scripts rather than interactive changes.  It's a matter, therefore, of writing some code.</i>",
            "id": "08df7ed5cca423e7f67af7ebd9840c7a"
          },
          {
            "type": "html",
            "text": " <i>Database refactoring, manual or otherwise, occupies such a small percentage of the overall database-driven application development process that most of the time it seems not worth bothering.</i>",
            "id": "943c108654d6c8b573b419cce1f9f07c"
          },
          {
            "type": "html",
            "text": " Really? or that is just some more of that I [[Just Dont Care If It Becomesa Maintenance Mightmare]] philosophy? ",
            "id": "4cfdc04066833777728765f348229e24"
          },
          {
            "type": "html",
            "text": " <i>Really.  >99% of my time is spent working on the application(s) side; <1% is spent working on the database, and that includes some big schemas that change relatively frequently.  For every minute spent making a change to the database, there will probably be at least an hour spent accommodating the change on the application side, unless it's a trivial change.  Having said that, I think such a tool is a great idea.  I'm not deprecating that.  I'm simply pointing out why I think it isn't a significant application category.</i>",
            "id": "811606555df9b643eb26810749baa3de"
          },
          {
            "type": "html",
            "text": " Well, that maybe so, specially if you are like me and use an [[Object Relational Mapper]] (and unlike those that believe that [[Databases Are More Than Just Storage]] and do code in stored procedures ,views and user functions)",
            "id": "31bf586ab4bc307e2c4a031820a984bd"
          },
          {
            "type": "html",
            "text": " <i>I don't use an [[Object Relational Mapper]], and I believe that [[Databases Are More Than Just Storage]] and a [[Database Is Representer Of Facts]].</i>",
            "id": "168b2896dc71f65aa363686b7e97d7e6"
          },
          {
            "type": "html",
            "text": " Well, then it is really amazing that >99% of your time is spent working on the application(s) side, if you do belive [[Databases Are More Than Just Storage]], then, how can you spend such a little time in the database? you certainly can not have a lot of your code in stored procedures, functions, triggers and stuff like that. ",
            "id": "e4ae0e1384b43096a1ed1da963f342a0"
          },
          {
            "type": "html",
            "text": " If you believe that [[Database Refactoring Tools]] will not help you... I [[Just Dont Get It]]... How can you believe that [[Databases Are More Than Just Storage]] and at the same time use them only for storage? (If you never write functions, triggers and stuff like that, and 99% of you code is on the application... and you don't like [[Object Relational Mappers]]... I am starting to believe that you may be masochistic... Maybe I just don't get how you code... ",
            "id": "be8099ebe88e116aa6d4e80911abe405"
          },
          {
            "type": "html",
            "text": " <i>The volume of application-side code is proportionally vast compared to the database-side code, and there is typically one database shared by multiple applications.  Stored procedures and triggers are typically used to handle specific core server-side functionality -- such as to support an employee scheduling engine, for example -- and change relatively rarely compared to the application-side.  The need for column, table, or procedure renamings is rare.  Deletions of columns or procedures is rare.  Much, much more common is adding tables and columns, which result in a relatively small server-side change volume, but may effect multiple client-side applications, and may require changes throughout each client-side application.  Also, changes to client-side applications or development of new applications that require no database changes are relatively common.  However, I do recognise that this may be somewhat domain-specific.  I can imagine domains where the database might require massive changes to reflect significant business changes, but that would still require significant -- and proportionally large -- changes to client-side applications.  In that case, I would be inclined to deploy a new schema and database that imports the existing one, rather than refactor the existing database.  Finally, I take an approach that does not mirror whole database entities as client-side objects.  I build applications to process information, i.e., facts; I do not create business simulators.  And, I'm not saying [[Database Refactoring Tools]] wouldn't help at all, just that they wouldn't help enough to motivate me to finish building one.</i>",
            "id": "7843348d540c0b6b2b452f23ce06eb8f"
          },
          {
            "type": "html",
            "text": " I can think of a very common time when the database might require massive changes to reflect significant business changes, and that is when you are creating the system for the first time, and, as  always, the requirements change every day.",
            "id": "d13f115177b2d6d24782567826e4ebab"
          },
          {
            "type": "html",
            "text": " <i>Yes, I've seen poorly-managed and/or poorly-analysed projects go haywire in that manner in the early stages, and a refactoring tool might help relieve the pain thereof.  Still, the percentage of overall project time that will be spent on the database, as opposed to working on the application-side code, is likely to be very small once the database requirements have stabilised.</i>",
            "id": "530e0367eb59f7ea8e04519ea951e3f3"
          },
          {
            "type": "html",
            "text": " Mmmm, what you say gives me the impression that you tend to get your database designs right on the first try (Something that in my opinion rarely happens, specially because Customers are not so good at explaining what do they expect from the software). Your customers usually have all their requirements correctly specified right from the beginning? Or... Do you handle this change in a way that wouldn't  be helped by [[Database Refactoring Tools]]? if that is the case... can you explain your methodology?.",
            "id": "9daf62e445bd529a592ff70896bbcbb6"
          },
          {
            "type": "html",
            "text": " <i>On the first try, I get the database design 100% right 0% of the time, 99% right about 1% of the time, but (throwing arbitrary statistics around here), I get it 95% right almost 100% of the time.  Most of the changes, however, tend to be minor -- adding columns, occasionally changing column type, and sometimes adding tables or turning an existing table into two in order to capture a one-to-many that escaped initial analysis.  Wholesale changes that necessitate a new schema?  Very rare.  Some reasons for this:</i>",
            "id": "b452aff3283c16ff61793735e9d9cb62"
          },
          {
            "type": "html",
            "text": " <i>We primarily (but not exclusively) developed (I'm using the past tense because I'm mainly doing university lecturing now) financial accounting, employee scheduling, billing, payroll and inventory systems, which generally have clear database design requirements even before analysis.  There are only so many ways to build a Canadian payroll system, for example, and the majority of core requirements are specified in government-provided documents.</i>",
            "id": "327a8d7697a7404f07bbc85b9071e5cd"
          },
          {
            "type": "html",
            "text": " <i>We employed a requirements-gathering methodology we developed in-house called the Forms-Based Analysis Method, which uses a combination of a diagramming methodology and a set of structured questions that are highly successful in reliably eliciting database requirements from the users.  (Published, with a co-author, in the Proceedings of the Western Decision Sciences Conference, San Francisco, California. 1995)</i>",
            "id": "e6201b0d8f7f782e28313e20a806173d"
          },
          {
            "type": "html",
            "text": " <i>The above is essentially [[Big Design Up Front]], rather than an agile methodology.  Subsequent client-side development is agile.  This combination seems quite effective in minimising difficult changes.</i>",
            "id": "a9a6706b20d0b73842592d1c5c38e9d6"
          },
          {
            "type": "html",
            "text": " <i>During development -- when little or no data need be retained -- the database schema can be trivially dumped, edited as a text file, and re-loaded.</i>",
            "id": "31cd5b988a487ada3d914bf3d20c00ba"
          },
          {
            "type": "html",
            "text": " <i>Sometimes changes are needed after deployment, but these are very rarely significant, as the users have generally been closely involved throughout the process.  We used an inversion of [[Onsite Customer]], in which the consultant developer spends significant time on the client's site -- sometimes even acting in an employee role -- in order to elicit and determine requirements, and obtain feedback on initial releases.</i>",
            "id": "8bca58f0966cbaf3160a641b61ce7575"
          },
          {
            "type": "html",
            "text": " <i>While application requirements are often unclear and changeable, database requirements tend to be quite rigid.  A given enterprise, department, or organisation tends to have numerous ways to clearly indicate exactly what it needs to record about its Customers, Employees, Products, etc.  These are found on printed forms, existing computer systems, Post-It(tm) Notes, catalogues, or whatever the business currently uses to record and/or distribute relevant information.  This becomes the basis of the database design.  What tends to change or be poorly-understood (or poorly-communicated by the users) is what the business </i>does<i> with this information.  That becomes the basis of client-side application functionality.</i>",
            "id": "2fd7ff2249528bbd7ac5a72031c9694f"
          },
          {
            "type": "html",
            "text": " And the idea of creating an [[Client Application To Database Mapper]] to make it possible to do refactorings all the way from the database to the client application would tempt you?",
            "id": "24ae3cf25328348869dd2b32beda68d3"
          },
          {
            "type": "html",
            "text": " <i>Yes, essentially.  I've added a comment to that effect to [[Client Application To Database Mapper]], though my idea is broader in scope than just a mapping layer.</i>",
            "id": "4ff65806df4a123aad37c5f19bf96972"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "da3f3b626c4065e92c69209b6b0591f3"
          },
          {
            "type": "html",
            "text": "\nSee also [[Table Normalization Issues]], [[Improve Databases Or Else]], [[Refactoring Databases Book]]",
            "id": "847d890d934b2eca1795b36031747909"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "da3f3b626c4065e92c69209b6b0591f3"
          },
          {
            "type": "html",
            "text": "[[April Zero Eight]]",
            "id": "e8460132d80b4497256a922a6911fd52"
          },
          {
            "type": "html",
            "text": "\n[[Category Refactoring]] [[Category Database]]",
            "id": "363d5e5b5e0a4f19045f2b3ca7686228"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DatabaseRefactoringTools c2.com]",
            "id": "75fa20b7f1974034e169a80d2e13bbb9"
          }
        ]
      }
    }
  ]
}